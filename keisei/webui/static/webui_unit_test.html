<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebUI Unit Test Suite</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: #1a1a2e;
            color: white;
            padding: 20px;
        }
        
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #444;
            border-radius: 8px;
        }
        
        .test-result {
            margin: 5px 0;
            padding: 8px;
            border-radius: 4px;
            font-family: monospace;
        }
        
        .pass { background: rgba(76, 205, 196, 0.3); color: #4ecdc4; }
        .fail { background: rgba(255, 107, 107, 0.3); color: #ff6b6b; }
        .warning { background: rgba(255, 193, 7, 0.3); color: #ffc107; }
        
        .mock-ui {
            display: none; /* Hide mock elements */
        }
        
        .chart-container { height: 100px; margin: 10px 0; }
        .chart { width: 100%; height: 100%; }
        
        .summary {
            font-size: 18px;
            font-weight: bold;
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <h1>üß™ WebUI Unit Test Suite</h1>
    <div id="test-summary" class="summary"></div>
    
    <!-- Mock UI Elements (hidden) -->
    <div class="mock-ui">
        <div id="timestep">0</div>
        <div id="episodes">0</div>
        <div id="speed">0.0</div>
        <div id="win-rate">0.0%</div>
        <div id="connection-status">Disconnected</div>
        <div id="game-status">Waiting</div>
        <div id="shogi-board"></div>
        <div id="sente-hand"></div>
        <div id="gote-hand"></div>
        <div id="black-wins">0</div>
        <div id="white-wins">0</div>
        <div id="draws">0</div>
        <div id="games-per-hour">0.0</div>
        <div id="avg-game-length">0</div>
        <div id="current-epoch">0</div>
        <div id="ep-metrics">Waiting</div>
        <div id="ppo-metrics">Waiting</div>
        <div id="buffer-progress"></div>
        <div id="buffer-text">0/0</div>
        <div id="gradient-norm">0.0</div>
        <div id="hot-squares"></div>
        <div id="processing-indicator" style="display: none;"></div>
        
        <!-- Charts -->
        <div class="chart-container"><canvas id="learning-chart" class="chart"></canvas></div>
        <div class="chart-container"><canvas id="winrate-chart" class="chart"></canvas></div>
        <div class="chart-container"><canvas id="ppo-chart" class="chart"></canvas></div>
        <div class="chart-container"><canvas id="episode-chart" class="chart"></canvas></div>
        
        <!-- Advanced visualizations -->
        <canvas id="neural-heatmap" width="100" height="100"></canvas>
        <canvas id="advantage-chart" width="100" height="100"></canvas>
        <canvas id="exploration-gauge" width="100" height="100"></canvas>
        <canvas id="skill-radar" width="100" height="100"></canvas>
        <canvas id="gradient-flow" width="100" height="100"></canvas>
        <canvas id="buffer-dynamics" width="100" height="100"></canvas>
        <canvas id="tournament-tree" width="100" height="100"></canvas>
        <canvas id="strategy-radar" width="100" height="100"></canvas>
    </div>
    
    <div id="test-results"></div>

    <script>
        // Unit Test Framework
        class WebUITestSuite {
            constructor() {
                this.tests = [];
                this.passed = 0;
                this.failed = 0;
                this.warnings = 0;
                
                // Initialize mock WebUI
                this.initMockWebUI();
            }
            
            initMockWebUI() {
                // Copy exact KeiseiWebUI initialization logic
                this.websocket = null;
                this.learningChart = null;
                this.winrateChart = null;
                this.ppoChart = null;
                this.episodeChart = null;
                
                this.pieces = {
                    'pawn': { black: 'Ê≠©', white: 'Ê≠©' },
                    'lance': { black: 'È¶ô', white: 'È¶ô' },
                    'knight': { black: 'Ê°Ç', white: 'Ê°Ç' },
                    'silver': { black: 'ÈäÄ', white: 'ÈäÄ' },
                    'gold': { black: 'Èáë', white: 'Èáë' },
                    'bishop': { black: 'Ëßí', white: 'Ëßí' },
                    'rook': { black: 'È£õ', white: 'È£õ' },
                    'king': { black: 'Áéã', white: 'Áéã' },
                    'promoted_pawn': { black: '„Å®', white: '„Å®' },
                    'promoted_lance': { black: 'ÊàêÈ¶ô', white: 'ÊàêÈ¶ô' },
                    'promoted_knight': { black: 'ÊàêÊ°Ç', white: 'ÊàêÊ°Ç' },
                    'promoted_silver': { black: 'ÊàêÈäÄ', white: 'ÊàêÈäÄ' },
                    'promoted_bishop': { black: 'È¶¨', white: 'È¶¨' },
                    'promoted_rook': { black: 'Èæç', white: 'Èæç' }
                };
                
                this.setupCharts();
                this.createBoard();
            }
            
            setupCharts() {
                try {
                    // Learning chart
                    this.learningChart = new Chart(document.getElementById('learning-chart'), {
                        type: 'line',
                        data: { labels: [], datasets: [
                            { label: 'Policy Loss', data: [], borderColor: '#ff6b6b' },
                            { label: 'Value Loss', data: [], borderColor: '#4ecdc4' },
                            { label: 'Entropy', data: [], borderColor: '#45b7d1' }
                        ]},
                        options: { responsive: true, maintainAspectRatio: false, animation: { duration: 0 } }
                    });
                    
                    // Win rate chart
                    this.winrateChart = new Chart(document.getElementById('winrate-chart'), {
                        type: 'line',
                        data: { labels: [], datasets: [
                            { label: 'Black Win %', data: [], borderColor: '#4ecdc4' },
                            { label: 'White Win %', data: [], borderColor: '#ff6b6b' },
                            { label: 'Draw %', data: [], borderColor: '#ffc107' }
                        ]},
                        options: { responsive: true, maintainAspectRatio: false, animation: { duration: 0 } }
                    });
                    
                    // PPO chart
                    this.ppoChart = new Chart(document.getElementById('ppo-chart'), {
                        type: 'line',
                        data: { labels: [], datasets: [
                            { label: 'KL Divergence', data: [], borderColor: '#9c27b0' },
                            { label: 'Clip Fraction', data: [], borderColor: '#ff9800' }
                        ]},
                        options: { responsive: true, maintainAspectRatio: false, animation: { duration: 0 } }
                    });
                    
                    // Episode chart
                    this.episodeChart = new Chart(document.getElementById('episode-chart'), {
                        type: 'line',
                        data: { labels: [], datasets: [
                            { label: 'Episode Length', data: [], borderColor: '#00bcd4' },
                            { label: 'Episode Reward', data: [], borderColor: '#8bc34a' }
                        ]},
                        options: { responsive: true, maintainAspectRatio: false, animation: { duration: 0 } }
                    });
                    
                    return true;
                } catch (e) {
                    console.error('Chart setup failed:', e);
                    return false;
                }
            }
            
            createBoard() {
                const board = document.getElementById('shogi-board');
                board.innerHTML = '';
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'board-cell';
                        cell.id = `cell-${row}-${col}`;
                        cell.style.display = 'inline-block';
                        cell.style.width = '20px';
                        cell.style.height = '20px';
                        cell.style.border = '1px solid #666';
                        board.appendChild(cell);
                    }
                }
            }
            
            // Test functions from the actual WebUI
            updateProgress(data) {
                try {
                    document.getElementById('timestep').textContent = data.global_timestep || 0;
                    document.getElementById('episodes').textContent = data.total_episodes || 0;
                    document.getElementById('speed').textContent = (data.speed || 0).toFixed(1);
                    
                    const totalGames = (data.black_wins || 0) + (data.white_wins || 0) + (data.draws || 0);
                    const blackWinRate = totalGames > 0 ? ((data.black_wins || 0) / totalGames * 100).toFixed(1) : 0;
                    document.getElementById('win-rate').textContent = `${blackWinRate}%`;
                    
                    document.getElementById('black-wins').textContent = data.black_wins || 0;
                    document.getElementById('white-wins').textContent = data.white_wins || 0;
                    document.getElementById('draws').textContent = data.draws || 0;
                    
                    return true;
                } catch (e) {
                    console.error('updateProgress failed:', e);
                    return false;
                }
            }
            
            updateBoard(data) {
                try {
                    if (!data.board) return false;
                    
                    // Clear board
                    const cells = document.querySelectorAll('.board-cell');
                    cells.forEach(cell => cell.innerHTML = '');
                    
                    // Update pieces
                    for (let row = 0; row < 9; row++) {
                        for (let col = 0; col < 9; col++) {
                            const cell = document.getElementById(`cell-${row}-${col}`);
                            const piece = data.board[row][col];
                            
                            if (piece) {
                                const pieceElement = document.createElement('div');
                                let className = `piece ${piece.color}`;
                                if (piece.color === 'white' && piece.type.startsWith('promoted_')) {
                                    className += ' no-rotate';
                                }
                                pieceElement.className = className;
                                
                                const symbol = this.pieces[piece.type]?.[piece.color] || piece.type;
                                pieceElement.textContent = symbol;
                                cell.appendChild(pieceElement);
                            }
                        }
                    }
                    
                    return true;
                } catch (e) {
                    console.error('updateBoard failed:', e);
                    return false;
                }
            }
            
            updateMetrics(data) {
                try {
                    if (!data.learning_curves) return false;
                    
                    const curves = data.learning_curves;
                    const maxLength = Math.max(
                        curves.policy_losses?.length || 0,
                        curves.value_losses?.length || 0,
                        curves.entropies?.length || 0
                    );
                    
                    if (maxLength > 0) {
                        const labels = Array.from({length: maxLength}, (_, i) => i);
                        
                        // Update learning chart
                        if (this.learningChart) {
                            this.learningChart.data.labels = labels;
                            this.learningChart.data.datasets[0].data = curves.policy_losses || [];
                            this.learningChart.data.datasets[1].data = curves.value_losses || [];
                            this.learningChart.data.datasets[2].data = curves.entropies || [];
                            this.learningChart.update('none');
                        }
                        
                        // Update other charts if data exists
                        if (this.ppoChart && curves.kl_divergences) {
                            this.ppoChart.data.labels = labels;
                            this.ppoChart.data.datasets[0].data = curves.kl_divergences;
                            this.ppoChart.data.datasets[1].data = curves.clip_fractions || [];
                            this.ppoChart.update('none');
                        }
                    }
                    
                    // Update text stats
                    if (data.game_statistics) {
                        document.getElementById('games-per-hour').textContent = (data.game_statistics.games_per_hour || 0).toFixed(1);
                        document.getElementById('avg-game-length').textContent = Math.round(data.game_statistics.average_game_length || 0);
                    }
                    
                    return true;
                } catch (e) {
                    console.error('updateMetrics failed:', e);
                    return false;
                }
            }
            
            // Test framework methods
            test(name, testFunc) {
                try {
                    const result = testFunc();
                    if (result === true) {
                        this.passed++;
                        this.logResult('PASS', name, 'Test passed');
                    } else if (result === false) {
                        this.failed++;
                        this.logResult('FAIL', name, 'Test failed');
                    } else {
                        this.warnings++;
                        this.logResult('WARN', name, result);
                    }
                } catch (error) {
                    this.failed++;
                    this.logResult('FAIL', name, `Exception: ${error.message}`);
                }
            }
            
            logResult(status, name, message) {
                const className = status === 'PASS' ? 'pass' : status === 'FAIL' ? 'fail' : 'warning';
                const result = `<div class="test-result ${className}">${status}: ${name} - ${message}</div>`;
                document.getElementById('test-results').innerHTML += result;
            }
            
            runAllTests() {
                console.log('üß™ Starting WebUI Unit Tests...');
                
                // Test 1: DOM Elements Exist
                this.test('DOM Elements Exist', () => {
                    const requiredElements = [
                        'timestep', 'episodes', 'speed', 'win-rate', 'connection-status',
                        'shogi-board', 'black-wins', 'white-wins', 'draws',
                        'learning-chart', 'winrate-chart', 'ppo-chart', 'episode-chart'
                    ];
                    
                    for (const id of requiredElements) {
                        if (!document.getElementById(id)) {
                            return `Missing element: ${id}`;
                        }
                    }
                    return true;
                });
                
                // Test 2: Charts Initialize
                this.test('Charts Initialize', () => {
                    if (!this.learningChart) return 'Learning chart not initialized';
                    if (!this.winrateChart) return 'Win rate chart not initialized';
                    if (!this.ppoChart) return 'PPO chart not initialized';
                    if (!this.episodeChart) return 'Episode chart not initialized';
                    return true;
                });
                
                // Test 3: Progress Update Function
                this.test('Progress Update Function', () => {
                    const testData = {
                        global_timestep: 1500,
                        total_episodes: 25,
                        speed: 3.14,
                        black_wins: 10,
                        white_wins: 8,
                        draws: 7
                    };
                    
                    if (!this.updateProgress(testData)) return false;
                    
                    if (document.getElementById('timestep').textContent !== '1500') return 'Timestep not updated';
                    if (document.getElementById('episodes').textContent !== '25') return 'Episodes not updated';
                    if (document.getElementById('speed').textContent !== '3.1') return 'Speed not updated';
                    if (document.getElementById('black-wins').textContent !== '10') return 'Black wins not updated';
                    
                    return true;
                });
                
                // Test 4: Board Update Function
                this.test('Board Update Function', () => {
                    const testBoard = Array(9).fill().map(() => Array(9).fill(null));
                    testBoard[0][0] = { type: 'king', color: 'black' };
                    testBoard[8][8] = { type: 'promoted_bishop', color: 'white' };
                    
                    const testData = { board: testBoard };
                    
                    if (!this.updateBoard(testData)) return false;
                    
                    const kingCell = document.getElementById('cell-0-0');
                    const bishopCell = document.getElementById('cell-8-8');
                    
                    if (!kingCell.textContent) return 'King not rendered';
                    if (!bishopCell.textContent) return 'Promoted bishop not rendered';
                    if (bishopCell.textContent === 'promoted_bishop') return 'Promoted bishop showing as text';
                    
                    return true;
                });
                
                // Test 5: Metrics Update Function
                this.test('Metrics Update Function', () => {
                    const testData = {
                        learning_curves: {
                            policy_losses: [0.5, 0.4, 0.3],
                            value_losses: [0.8, 0.7, 0.6],
                            entropies: [1.0, 0.9, 0.8],
                            kl_divergences: [0.01, 0.02, 0.01],
                            clip_fractions: [0.1, 0.15, 0.2]
                        },
                        game_statistics: {
                            games_per_hour: 12.5,
                            average_game_length: 45
                        }
                    };
                    
                    if (!this.updateMetrics(testData)) return false;
                    
                    if (this.learningChart.data.datasets[0].data.length !== 3) return 'Learning chart data not updated';
                    if (document.getElementById('games-per-hour').textContent !== '12.5') return 'Games per hour not updated';
                    
                    return true;
                });
                
                // Test 6: Piece Mapping
                this.test('Piece Mapping', () => {
                    const testPieces = [
                        { type: 'king', color: 'black', expected: 'Áéã' },
                        { type: 'promoted_bishop', color: 'white', expected: 'È¶¨' },
                        { type: 'promoted_knight', color: 'black', expected: 'ÊàêÊ°Ç' }
                    ];
                    
                    for (const piece of testPieces) {
                        const symbol = this.pieces[piece.type]?.[piece.color];
                        if (symbol !== piece.expected) {
                            return `Wrong symbol for ${piece.type} ${piece.color}: got "${symbol}", expected "${piece.expected}"`;
                        }
                    }
                    return true;
                });
                
                // Update summary
                const total = this.passed + this.failed + this.warnings;
                const summary = document.getElementById('test-summary');
                if (this.failed > 0) {
                    summary.className = 'summary fail';
                    summary.innerHTML = `‚ùå TESTS FAILED: ${this.failed}/${total} failed, ${this.passed} passed, ${this.warnings} warnings`;
                } else {
                    summary.className = 'summary pass';
                    summary.innerHTML = `‚úÖ ALL TESTS PASSED: ${this.passed}/${total} passed, ${this.warnings} warnings`;
                }
                
                console.log(`üß™ Tests completed: ${this.passed} passed, ${this.failed} failed, ${this.warnings} warnings`);
            }
        }
        
        // Run tests when page loads
        document.addEventListener('DOMContentLoaded', () => {
            const testSuite = new WebUITestSuite();
            testSuite.runAllTests();
        });
    </script>
</body>
</html>